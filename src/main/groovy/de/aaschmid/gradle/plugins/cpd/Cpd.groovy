package de.aaschmid.gradle.plugins.cpd

import de.aaschmid.gradle.plugins.cpd.internal.CpdExecutor
import de.aaschmid.gradle.plugins.cpd.internal.CpdReporter
import de.aaschmid.gradle.plugins.cpd.internal.CpdReportsImpl
import net.sourceforge.pmd.cpd.Match
import org.gradle.api.GradleException
import org.gradle.api.Incubating
import org.gradle.api.file.FileCollection
import org.gradle.api.internal.project.IsolatedAntBuilder
import org.gradle.api.reporting.Reporting
import org.gradle.api.reporting.SingleFileReport
import org.gradle.api.tasks.Input
import org.gradle.api.tasks.InputFiles
import org.gradle.api.tasks.Nested
import org.gradle.api.tasks.SourceTask
import org.gradle.api.tasks.TaskAction
import org.gradle.api.tasks.VerificationTask
import org.gradle.internal.reflect.Instantiator
import org.gradle.logging.ConsoleRenderer

import javax.inject.Inject
import org.gradle.api.logging.Logger
import org.gradle.api.logging.Logging

/**
 * Runs static code/paste (= duplication) detection on supplied source code files and generates a report of duplications
 * found.
 * <p>
 * Sample:
 *
 * <pre autoTested=''>
 * apply plugin: 'cpd'
 *
 * task cpd(type: Cpd, description: 'Copy/Paste detection for all Ruby scripts') {
 *
 *     // set minimum token count causing a duplication warning
 *     minimumTokenCount = 10
 *
 *     // enable CSV reports and customize destination, disable xml report
 *     reports {
 *         csv {
 *             enabled = true
 *             destination = file("${buildDir}/cpd.csv")
 *         }
 *         xml.enabled = false
 *     }
 *
 *     // explicitly include all Ruby files and exclude tests
 *     include '**.rb'
 *     exclude '**Test*'
 *
 *     // set source for running duplication check on
 *     source = files('src/ruby')
 * }
 * </pre>
 *
 * @see CpdPlugin
 */
@Incubating
class Cpd extends SourceTask implements VerificationTask, Reporting<CpdReports> {

    private static final Logger logger = Logging.getLogger(Cpd.class);

    private final CpdExecutor executor
    private final CpdReporter reporter

    /**
     * The character set encoding (e.g., UTF-8) to use when reading the source code files but also when producing the
     * report; defaults to {@link CpdExtension#getEncoding()}.
     * <p>
     * Example: {@code encoding = UTF-8}
     */
    @Input
    String encoding

    /**
     * Whether or not to allow the build to continue if there are warnings.
     * <p>
     * Example: {@code ignoreFailures = true}
     */
    @Input
    boolean ignoreFailures

    /**
     * A positive integer indicating the minimum token count to trigger a CPD match; defaults to
     * {@link CpdExtension#getMinimumTokenCount()}.
     * <p>
     * Example: {@code minimumTokenCount = 25}
     */
    @Input
    int minimumTokenCount

    /**
     * The class path containing the PMD library which contains the CPD library to be used.
     */
    @InputFiles
    FileCollection pmdClasspath

    @Nested
    private final CpdReportsImpl reports

    @Inject
    Cpd(Instantiator instantiator) {
        this.reports = instantiator.newInstance(CpdReportsImpl, this)

        this.executor = new CpdExecutor(this)
        this.reporter = new CpdReporter(this)
    }

    @TaskAction
    void run() {
        executor.canRun();
        reporter.canGenerate();

        // use getter to access properties that they are resolved correctly using conventionMapping

        List<Match> matches = executor.run()
        reporter.generate(matches)
        logResult(matches)
    }

    private void logResult(List<Match> matches) {
        if (matches.isEmpty()) {
            if (logger.isInfoEnabled()) {
                logger.info('No duplicates over {} tokens found.', getMinimumTokenCount())
            }

        } else {
            String message = "CPD found duplicate code.";
            SingleFileReport report = reports.getFirstEnabled();
            if (report != null) {
                String reportUrl = new ConsoleRenderer().asClickableFileUrl(report.getDestination());
                message += " See the report at ${reportUrl}";
            }
            if (getIgnoreFailures()) {
                if (logger.isWarnEnabled()) {
                    logger.warn(message);
                }
            } else {
                throw new GradleException(message);
            }
        }
    }

    /**
     * Configures the reports to be generated by this task.
     */
    @Override
    CpdReports reports(Closure closure) {
        return reports.configure(closure)
    }

    /**
     * Returns the reports to be generated by this task.
     */
    @Override
    CpdReports getReports() {
        return reports
    }
}
